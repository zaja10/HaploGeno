message("Imputing missing data...")
haplo$impute_genotypes(method = "mean")
message("Defining haplotype blocks...")
haplo$define_blocks_ld(r2_threshold = 0.1, window_size = 100)
message("Encoding haplotypes and computing HRM...")
haplo$encode_haplotypes(n_cores = 2)
haplo$compute_hrm(n_cores = 2)
# --- 4. Prediction (KRR) ---
message("Running Cross-Validation...")
cv_results <- haplo$cross_validate(k = 5, n_cores = 2)
best_lambda <- cv_results$best_lambda
message("Best Lambda found: ", best_lambda)
message("Fitting final model...")
alpha <- haplo$fit_krr(lambda = best_lambda)
# --- 5. Visualization ---
message("Plotting Manhattan plot...")
haplo$estimate_marker_effects(lambda = best_lambda)
haplo$calculate_local_gebv(n_cores = 2)
haplo$run_significance_test(n_perm = 100, n_cores = 2)
haplo$plot_manhattan(threshold = 0.05)
haplo$run_significance_test(n_perm = 100)
View(haplo)
Rcpp::compileAttributes()
# 1. Update Rcpp exports (generates R/RcppExports.R and src/RcppExports.cpp)
Rcpp::compileAttributes()
# 2. Re-install the package to compile the new C++ code
devtools::install()
# OR if you are developing interactively:
# devtools::load_all()
library(bigstatsr)
library(future)
library(rrBLUP)
library(BGLR)
library(microbenchmark)
# Benchmark function
run_benchmark <- function(n, m) {
message("Benchmarking with N=", n, ", M=", m, "...")
# Simulate data
set.seed(123)
X <- matrix(sample(0:2, n * m, replace = TRUE), nrow = n, ncol = m)
map <- data.frame(chr = rep(1, m), id = paste0("snp", 1:m), pos = 1:m, ref = "A", alt = "G")
eff <- rnorm(m / 10)
y <- as.vector(X[, 1:(m/10)] %*% eff + rnorm(n))
# rrBLUP setup
# rrBLUP expects markers in (-1, 0, 1)
X_rr <- X - 1
# HaploGeno setup
haplo <- HaploObject$new(tempfile())
haplo$import_genotypes(X)
haplo$load_map(map)
haplo$load_pheno(y)
res <- microbenchmark(
HaploGeno = {
haplo$define_blocks_ld(r2_threshold = 0.1, window_size = 100)
haplo$encode_haplotypes(n_cores = 1)
haplo$compute_hrm(n_cores = 1)
haplo$fit_krr(lambda = 1.0)
},
rrBLUP = {
K <- A.mat(X_rr)
mixed.solve(y, K = K)
},
times = 5
)
return(res)
}
# Run benchmarks
results_500 <- run_benchmark(500, 2000)
# Source package files directly to avoid build issues
source("R/HaploObject.R")
source("R/S3Methods.R")
# Benchmark function
run_benchmark <- function(n, m) {
message("Benchmarking with N=", n, ", M=", m, "...")
# Simulate data
set.seed(123)
X <- matrix(sample(0:2, n * m, replace = TRUE), nrow = n, ncol = m)
map <- data.frame(chr = rep(1, m), id = paste0("snp", 1:m), pos = 1:m, ref = "A", alt = "G")
eff <- rnorm(m / 10)
y <- as.vector(X[, 1:(m/10)] %*% eff + rnorm(n))
# rrBLUP setup
# rrBLUP expects markers in (-1, 0, 1)
X_rr <- X - 1
# HaploGeno setup
haplo <- HaploObject$new(tempfile())
haplo$import_genotypes(X)
haplo$load_map(map)
haplo$load_pheno(y)
res <- microbenchmark(
HaploGeno = {
haplo$define_blocks_ld(r2_threshold = 0.1, window_size = 100)
haplo$encode_haplotypes(n_cores = 1)
haplo$compute_hrm(n_cores = 1)
haplo$fit_krr(lambda = 1.0)
},
rrBLUP = {
K <- A.mat(X_rr)
mixed.solve(y, K = K)
},
times = 5
)
return(res)
}
# Run benchmarks
results_500 <- run_benchmark(500, 2000)
library(bigstatsr)
library(future)
library(rrBLUP)
library(BGLR)
library(microbenchmark)
# Benchmark function
run_benchmark <- function(n, m) {
message("Benchmarking with N=", n, ", M=", m, "...")
# Simulate data
set.seed(123)
X <- matrix(sample(0:2, n * m, replace = TRUE), nrow = n, ncol = m)
map <- data.frame(chr = rep(1, m), id = paste0("snp", 1:m), pos = 1:m, ref = "A", alt = "G")
eff <- rnorm(m / 10)
y <- as.vector(X[, 1:(m/10)] %*% eff + rnorm(n))
# rrBLUP setup
# rrBLUP expects markers in (-1, 0, 1)
X_rr <- X - 1
# HaploGeno setup
haplo <- HaploObject$new(tempfile())
haplo$import_genotypes(X)
haplo$load_map(map)
haplo$load_pheno(y)
res <- microbenchmark(
HaploGeno = {
haplo$define_blocks_ld(r2_threshold = 0.1, window_size = 100)
haplo$encode_haplotypes(n_cores = 1)
haplo$compute_hrm(n_cores = 1)
haplo$fit_krr(lambda = 1.0)
},
rrBLUP = {
K <- A.mat(X_rr)
mixed.solve(y, K = K)
},
times = 5
)
return(res)
}
# Run benchmarks
results_500 <- run_benchmark(500, 2000)
# Source package files directly to avoid build issues
source("R/HaploObject.R")
source("R/S3Methods.R")
# Benchmark function
run_benchmark <- function(n, m) {
message("Benchmarking with N=", n, ", M=", m, "...")
# Simulate data
set.seed(123)
X <- matrix(sample(0:2, n * m, replace = TRUE), nrow = n, ncol = m)
map <- data.frame(chr = rep(1, m), id = paste0("snp", 1:m), pos = 1:m, ref = "A", alt = "G")
eff <- rnorm(m / 10)
y <- as.vector(X[, 1:(m/10)] %*% eff + rnorm(n))
# rrBLUP setup
# rrBLUP expects markers in (-1, 0, 1)
X_rr <- X - 1
# HaploGeno setup
haplo <- HaploObject$new(tempfile())
haplo$import_genotypes(X)
haplo$load_map(map)
haplo$load_pheno(y)
res <- microbenchmark(
HaploGeno = {
haplo$define_blocks_ld(r2_threshold = 0.1, window_size = 100)
haplo$encode_haplotypes(n_cores = 1)
haplo$compute_hrm(n_cores = 1)
haplo$fit_krr(lambda = 1.0)
},
rrBLUP = {
K <- A.mat(X_rr)
mixed.solve(y, K = K)
},
times = 5
)
return(res)
}
# Run benchmarks
results_500 <- run_benchmark(500, 2000)
devtools::install()
# Run benchmarks
results_500 <- run_benchmark(500, 2000)
library(bigstatsr)
library(future)
library(rrBLUP)
library(BGLR)
library(microbenchmark)
# Source package files directly to avoid build issues
source("R/HaploObject.R")
source("R/S3Methods.R")
# Benchmark function
run_benchmark <- function(n, m) {
message("Benchmarking with N=", n, ", M=", m, "...")
# Simulate data
set.seed(123)
X <- matrix(sample(0:2, n * m, replace = TRUE), nrow = n, ncol = m)
map <- data.frame(chr = rep(1, m), id = paste0("snp", 1:m), pos = 1:m, ref = "A", alt = "G")
eff <- rnorm(m / 10)
y <- as.vector(X[, 1:(m/10)] %*% eff + rnorm(n))
# rrBLUP setup
# rrBLUP expects markers in (-1, 0, 1)
X_rr <- X - 1
# HaploGeno setup
haplo <- HaploObject$new(tempfile())
haplo$import_genotypes(X)
haplo$load_map(map)
haplo$load_pheno(y)
res <- microbenchmark(
HaploGeno = {
haplo$define_blocks_ld(r2_threshold = 0.1, window_size = 100)
haplo$encode_haplotypes(n_cores = 1)
haplo$compute_hrm(n_cores = 1)
haplo$fit_krr(lambda = 1.0)
},
rrBLUP = {
K <- A.mat(X_rr)
mixed.solve(y, K = K)
},
times = 5
)
return(res)
}
# Run benchmarks
results_500 <- run_benchmark(500, 2000)
print(results_500)
# Plot using base R
boxplot(results_500, main = "HaploGeno vs rrBLUP (N=500, M=2000)")
library(HaploGeno)
library(bigstatsr)
# --- 1. Simulate Data ---
set.seed(123)
n <- 200    # Individuals
m <- 2000   # Markers
# Generate random genotypes (0, 1, 2)
X <- matrix(sample(0:2, n * m, replace = TRUE), nrow = n, ncol = m)
# Introduce 1% missing data to test imputation
X[sample(length(X), length(X) * 0.01)] <- NA
# Create a dummy marker map
map <- data.frame(
chr = rep(1, m),
id = paste0("snp", 1:m),
pos = 1:m,
ref = "A", alt = "G"
)
# Simulate phenotype (effects in first 100 markers)
eff <- rnorm(100)
y <- as.vector(X[, 1:100] %*% eff + rnorm(n))
y[is.na(y)] <- 0 # Simple fix for demo
# --- 2. Initialize & Load ---
# Create the file-backed object in a temporary file
haplo <- HaploObject$new(tempfile())
message("Importing data...")
haplo$import_genotypes(X)
haplo$load_map(map)
haplo$load_pheno(y)
# --- 3. Run Pipeline ---
message("Imputing missing data...")
haplo$impute_genotypes(method = "mean")
message("Defining haplotype blocks...")
haplo$define_blocks_ld(r2_threshold = 0.1, window_size = 100)
haplo$define_blocks_ld(r2_threshold = 0.4, window_size = 100)
message("Encoding haplotypes and computing HRM...")
haplo$encode_haplotypes(n_cores = 2)
haplo$compute_hrm(n_cores = 2)
# --- 4. Prediction (KRR) ---
message("Running Cross-Validation...")
cv_results <- haplo$cross_validate(k = 5, n_cores = 2)
best_lambda <- cv_results$best_lambda
message("Best Lambda found: ", best_lambda)
message("Fitting final model...")
alpha <- haplo$fit_krr(lambda = best_lambda)
# --- 5. Visualization ---
message("Plotting Manhattan plot...")
haplo$estimate_marker_effects(lambda = best_lambda)
haplo$calculate_local_gebv(n_cores = 2)
haplo$test_significance()
haplo$plot_manhattan(threshold = 0.05)
haplo$plot_pca()
haplo$plot_gebv_image()
# 1. Identify the top 20 most significant blocks
top_haplos <- haplo$identify_superior_haplotypes(top_n = 20)
# 2. Score individuals based on how many of these superior haplotypes they possess
scores <- haplo$score_stacking(top_haplos)
# 3. Plot the trend
message("Plotting Stacking Trend...")
haplo$plot_stacking_trend(scores, top_haplos)
Rcpp::compileAttributes()
devtools::install()
library(HaploGeno)
library(bigstatsr)
library(future)
library(HaploGeno)
# Load the pre-processed demo dataset
haplo <- load_demo_data()
# Print the object summary to verify data status
print(haplo)
# Plot the first two principal components of the HRM
haplo$plot_pca()
# Plot significance of local GEBV variances
# The threshold defaults to p < 0.05
haplo$plot_manhattan(threshold = 0.05)
# Visualize the Local GEBV matrix
# X-axis: Block Index
# Y-axis: Individual Index
# Color: Blue (Low Value) to Red (High Value)
haplo$plot_gebv_image()
# Identify the best haplotype for the top 10 most significant blocks
superior_haplos <- haplo$identify_superior_haplotypes(top_n = 10)
# View the results
print(head(superior_haplos))
# Calculate stacking scores for all individuals
scores <- haplo$score_stacking(superior_haplos)
# View scores for the first few individuals
head(scores)
# Plot the stacking trend with a regression line and R-squared value
haplo$plot_stacking_trend(scores = scores)
devtools::install()
## ----setup--------------------------------------------------------------------
library(HaploGeno)
## ----load_demo----------------------------------------------------------------
# Load the pre-processed demo dataset
haplo <- load_demo_data()
# Print the object summary to verify data status
print(haplo)
## ----pca, fig.width=6, fig.height=6-------------------------------------------
# Plot the first two principal components of the HRM
haplo$plot_pca()
## ----manhattan, fig.width=7, fig.height=5-------------------------------------
# Plot significance of local GEBV variances
# The threshold defaults to p < 0.05
haplo$plot_manhattan(threshold = 0.05)
## ----heatmap, fig.width=7, fig.height=6---------------------------------------
# Visualize the Local GEBV matrix
# X-axis: Block Index
# Y-axis: Individual Index
# Color: Blue (Low Value) to Red (High Value)
haplo$plot_gebv_image()
## ----superior-----------------------------------------------------------------
# Identify the best haplotype for the top 10 most significant blocks
superior_haplos <- haplo$identify_superior_haplotypes(top_n = 10)
# View the results
print(head(superior_haplos))
## ----scoring------------------------------------------------------------------
# Calculate stacking scores for all individuals
scores <- haplo$score_stacking(superior_haplos)
# View scores for the first few individuals
head(scores)
## ----trend, fig.width=6, fig.height=6-----------------------------------------
# Plot the stacking trend with a regression line and R-squared value
haplo$plot_stacking_trend(scores = scores)
library(HaploGeno)
# Analyze a specific block (e.g., Block 1 which we know has signal)
# This function scales effects, detects peaks, and runs a t-test
hoi_res <- haplo$analyze_hoi(local_gebv = haplo$local_gebv, block_id = 1)
# Inspect the results
print(paste("P-value for separation:", format(hoi_res$p_value, digits = 4)))
print("Superior Haplotypes:")
print(hoi_res$hoi_haplotypes)
# Extract effects for Block 1
block_effects <- haplo$local_gebv$matrix[, 1]
scaled_effects <- haplo$scale_haplo_effects(matrix(block_effects, ncol=1))
# Plot density
plot(density(scaled_effects), main = "Distribution of Haplotype Effects (Block 1)",
xlab = "Scaled Effect Size", col = "blue", lwd = 2)
abline(v = hoi_res$peaks, col = "red", lty = 2) # Mark peaks
abline(v = hoi_res$nadir, col = "darkgreen", lty = 1, lwd = 2) # Mark split point
legend("topleft", legend = c("Density", "Peaks", "Split Nadir"),
col = c("blue", "red", "darkgreen"), lty = c(1, 2, 1), lwd = 2)
devtools::load_all()
library(HaploGeno)
# Extract effects for Block 1
block_effects <- haplo$local_gebv$matrix[, 1]
library(HaploGeno)
# Load the pre-processed demo dataset
haplo <- load_demo_data()
# Print the object summary to verify data status
print(haplo)
# Plot the first two principal components of the HRM
haplo$plot_pca()
# Plot significance of local GEBV variances
# The threshold defaults to p < 0.05
haplo$plot_manhattan(threshold = 0.05)
# Visualize the Local GEBV matrix
# X-axis: Block Index
# Y-axis: Individual Index
# Color: Blue (Low Value) to Red (High Value)
haplo$plot_gebv_image()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(HaploGeno)
# Load the pre-processed demo dataset
haplo <- load_demo_data()
# Print the object summary to verify data status
print(haplo)
# Plot the first two principal components of the HRM
haplo$plot_pca()
# Plot significance of local GEBV variances
# The threshold defaults to p < 0.05
haplo$plot_manhattan(threshold = 0.05)
# Visualize the Local GEBV matrix
# X-axis: Block Index
# Y-axis: Individual Index
# Color: Blue (Low Value) to Red (High Value)
haplo$plot_gebv_image()
# Identify the best haplotype for the top 10 most significant blocks
superior_haplos <- haplo$identify_superior_haplotypes(top_n = 10)
# View the results
print(head(superior_haplos))
# Calculate stacking scores for all individuals
scores <- haplo$score_stacking(superior_haplos)
# View scores for the first few individuals
head(scores)
# Plot the stacking trend with a regression line and R-squared value
haplo$plot_stacking_trend(scores = scores)
# Analyze a specific block (e.g., Block 1 which we know has signal)
# This function scales effects, detects peaks, and runs a t-test
hoi_res <- haplo$analyze_hoi(local_gebv = haplo$local_gebv, block_id = 1)
# Inspect the results
print(paste("P-value for separation:", format(hoi_res$p_value, digits = 4)))
print("Superior Haplotypes:")
print(hoi_res$hoi_haplotypes)
# Extract effects for Block 1
block_effects <- haplo$local_gebv$matrix[, 1]
scaled_effects <- haplo$scale_haplo_effects(matrix(block_effects, ncol = 1))
# Plot density
plot(density(scaled_effects),
main = "Distribution of Haplotype Effects (Block 1)",
xlab = "Scaled Effect Size", col = "blue", lwd = 2
)
abline(v = hoi_res$peaks, col = "red", lty = 2) # Mark peaks
abline(v = hoi_res$nadir, col = "darkgreen", lty = 1, lwd = 2) # Mark split point
legend("topleft",
legend = c("Density", "Peaks", "Split Nadir"),
col = c("blue", "red", "darkgreen"), lty = c(1, 2, 1), lwd = 2
)
# Plot the biplot showing the top 5 blocks
# This shows which blocks are driving the separation along the principal components
haplo$plot_haplo_biplot(top_n = 5, label_blocks = TRUE)
# Visualize the Local GEBV matrix
# X-axis: Block Index
# Y-axis: Individual Index
# Color: Blue (Low Value) to Red (High Value)
haplo$plot_gebv_image()
# Plot the biplot showing the top 5 blocks
# This shows which blocks are driving the separation along the principal components
haplo$plot_haplo_biplot(top_n = 5, label_blocks = TRUE)
devtools::load_all()
library(HaploGeno)
# Load the pre-processed demo dataset
haplo <- load_demo_data()
# Print the object summary to verify data status
print(haplo)
# Plot the first two principal components of the HRM
haplo$plot_pca()
# Plot significance of local GEBV variances
# The threshold defaults to p < 0.05
haplo$plot_manhattan(threshold = 0.05)
# Visualize the Local GEBV matrix
# X-axis: Block Index
# Y-axis: Individual Index
# Color: Blue (Low Value) to Red (High Value)
haplo$plot_gebv_image()
# Identify the best haplotype for the top 10 most significant blocks
superior_haplos <- haplo$identify_superior_haplotypes(top_n = 10)
# View the results
print(head(superior_haplos))
# Calculate stacking scores for all individuals
scores <- haplo$score_stacking(superior_haplos)
# View scores for the first few individuals
head(scores)
# Plot the stacking trend with a regression line and R-squared value
haplo$plot_stacking_trend(scores = scores)
# Analyze a specific block (e.g., Block 1 which we know has signal)
# This function scales effects, detects peaks, and runs a t-test
hoi_res <- haplo$analyze_hoi(local_gebv = haplo$local_gebv, block_id = 1)
# Inspect the results
print(paste("P-value for separation:", format(hoi_res$p_value, digits = 4)))
print("Superior Haplotypes:")
print(hoi_res$hoi_haplotypes)
# Visualize distribution with simplified method
# We can also highlight specific "check" genotypes (e.g., individuals 1, 10, 20)
haplo$plot_hoi_distribution(block_id = 1, highlight_ind = c(1, 10, 20))
# Plot the biplot showing the top 5 blocks
# This shows which blocks are driving the separation along the principal components
haplo$plot_haplo_biplot(top_n = 5, label_blocks = TRUE)
# Visualize distribution with simplified method
# We can also highlight specific "check" genotypes (e.g., individuals 1, 10, 20)
haplo$plot_hoi_distribution(block_id = 1, highlight_ind = c(1, 19))
plot_hoi_distribution
haplo
haplo$hoi
View(hoi_res)
View(superior_haplos)
# Visualize distribution with simplified method
# We can also highlight specific "check" genotypes (e.g., individuals 1, 10, 20)
haplo$plot_hoi_distribution(block_id = 1, highlight_ind = c(1, 37))
# Visualize distribution with simplified method
# We can also highlight specific "check" genotypes (e.g., individuals 1, 10, 20)
haplo$plot_hoi_distribution(block_id = 1, highlight_ind = c(1, 2))
# Visualize distribution with simplified method
# We can also highlight specific "check" genotypes (e.g., individuals 1, 10, 20)
haplo$plot_hoi_distribution(block_id = 1, highlight_ind = c(1, 2))
# Visualize distribution with simplified method
# We can also highlight specific "check" genotypes (e.g., individuals 1, 10, 20)
haplo$plot_hoi_distribution(block_id = 1, highlight_ind = c(1, 4))
# Visualize distribution with simplified method
# We can also highlight specific "check" genotypes (e.g., individuals 1, 10, 20)
haplo$plot_hoi_distribution(block_id = 1, highlight_ind = c(1, "4"))
